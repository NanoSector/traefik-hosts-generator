package file_writer

import (
	"github.com/pkg/errors"
	"io/ioutil"
	"os"
	"strings"
)

const (
	EntriesHeader = "######## AUTOGENERATED BY TRAEFIK_HOSTS_GENERATOR ################"
	EntriesFooter = "######## AUTOGENERATED BY TRAEFIK_HOSTS_GENERATOR END ############"
)

type Writer struct {
	postfix       string
	lineEndings   string
	hostsLocation string
	entriesHeader string
	entriesFooter string
}

func NewWriter(hostsLocation, lineEndings, postfix string) *Writer {
	return &Writer{
		postfix:       postfix,
		lineEndings:   lineEndings,
		hostsLocation: hostsLocation,
		entriesHeader: EntriesHeader + " " + postfix,
		entriesFooter: EntriesFooter + " " + postfix,
	}
}

func (w *Writer) WriteToHosts(newHosts string) error {
	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return errors.Wrap(err, "reading current file content failed")
	}

	headerPresent := w.isHeaderPresent(currentContent)
	footerPresent := w.isFooterPresent(currentContent)

	if headerPresent && footerPresent {
		return w.replaceContent(newHosts)
	}

	if !headerPresent && !footerPresent {
		return w.insertContent(newHosts)
	}

	return errors.New("hosts content malformed, traefik section is partially present")
}

func (w *Writer) Clear() error {
	headerStart, footerStart, err := w.getCurrentPositions()
	if err != nil {
		return err
	}
	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return err
	}

	fullCurrentContext := currentContent[headerStart : footerStart+len(w.entriesFooter)]

	newContent := strings.Replace(currentContent, fullCurrentContext, w.lineEndings, -1)

	err = ioutil.WriteFile(w.hostsLocation, []byte(newContent), 0)
	if err != nil {
		return errors.Wrap(err, "cannot write new hosts content")
	}
	return nil
}

func (w *Writer) getCurrentHostsContent() (string, error) {
	content, err := ioutil.ReadFile(w.hostsLocation)
	if err != nil {
		return "", nil
	}

	return string(content), nil
}

func (w *Writer) insertContent(newHosts string) error {
	f, err := os.OpenFile(w.hostsLocation, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		return err
	}

	defer f.Close()
	newHosts = w.entriesHeader + w.lineEndings + newHosts + w.lineEndings + w.entriesFooter

	if _, err = f.WriteString(newHosts); err != nil {
		return err
	}
	return nil
}

func (w *Writer) getCurrentPositions() (headerStart, footerStart int, err error) {
	var currentContent string
	currentContent, err = w.getCurrentHostsContent()
	if err != nil {
		return
	}
	headerStart = strings.Index(currentContent, w.entriesHeader)
	footerStart = strings.Index(currentContent, w.entriesFooter)
	return
}

func (w *Writer) getCurrentGeneratedHosts() (string, error) {
	headerStart, footerStart, err := w.getCurrentPositions()
	if err != nil {
		return "", err
	}
	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return "", err
	}
	return currentContent[headerStart+len(w.entriesHeader) : footerStart], nil
}

func (w *Writer) replaceContent(newHosts string) error {
	oldContent, err := w.getCurrentGeneratedHosts()
	if err != nil {
		return err
	}

	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return err
	}
	newContent := strings.Replace(currentContent, oldContent, w.lineEndings+newHosts, -1)

	err = ioutil.WriteFile(w.hostsLocation, []byte(newContent), 0)
	if err != nil {
		return errors.Wrap(err, "cannot write new hosts content")
	}

	return nil
}

func (w *Writer) isHeaderPresent(content string) bool {
	return strings.Contains(content, w.entriesHeader)
}

func (w *Writer) isFooterPresent(content string) bool {
	return strings.Contains(content, w.entriesFooter)
}
